<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç People Counting System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            height: calc(100vh - 200px);
        }

        .video-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select, input, button {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .stop-btn {
            background: linear-gradient(45deg, #f44336, #d32f2f) !important;
        }

        .reset-btn {
            background: linear-gradient(45deg, #ff9800, #f57c00) !important;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            height: calc(100% - 80px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #videoFeed {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .no-video {
            font-size: 1.2em;
            color: #ccc;
            text-align: center;
        }

        .stats-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
        }

        .stats-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .stats-header h2 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .in-count { color: #4CAF50; }
        .out-count { color: #f44336; }
        .net-count { color: #ff9800; }
        .zone-count { color: #2196F3; }

        .log-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid #4CAF50;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry.error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .log-entry.warning {
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .log-entry.info {
            border-left-color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }

        .timestamp {
            color: #ccc;
            font-size: 0.8em;
            margin-right: 10px;
        }

        .drawing-instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }

        .instruction-box {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }

        .clear-btn {
            padding: 5px 10px !important;
            font-size: 0.8em !important;
            background: linear-gradient(45deg, #f44336, #d32f2f) !important;
            margin: 0 !important;
        }

        button[id="drawBtn"] {
            background: linear-gradient(45deg, #9c27b0, #7b1fa2) !important;
        }

        #videoCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-stopped { background-color: #f44336; }
        .status-running { background-color: #4CAF50; }
        .status-connecting { background-color: #ff9800; }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .stats-panel {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: center;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 1000;
        }

        .connected {
            background: rgba(76, 175, 80, 0.9);
        }

        .disconnected {
            background: rgba(244, 67, 54, 0.9);
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        <span class="status-indicator status-connecting"></span>
        ƒêang k·∫øt n·ªëi...
    </div>

    <div class="container">
        <div class="header">
            <h1>üîç H·ªá Th·ªëng ƒê·∫øm Ng∆∞·ªùi</h1>
            <p>Real-time People Counting v·ªõi AI Detection</p>
        </div>

        <div class="main-content">
            <div class="video-section">
                <div class="controls">
                    <div class="control-group">
                        <label>Ph∆∞∆°ng ph√°p:</label>
                        <select id="methodSelect">
                            <option value="line">üìä Line Counting</option>
                            <option value="zone">üè¢ Zone Counting</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Video:</label>
                        <input type="text" id="videoInput" placeholder="Test.mp4 ho·∫∑c 0" value="Test.mp4">
                    </div>
                    
                    <div class="control-group">
                        <label>Model:</label>
                        <select id="modelSelect">
                            <optgroup label="PyTorch Models">
                                <option value="yolov8n.pt">YOLOv8n (nhanh)</option>
                                <option value="yolov8s.pt" selected>YOLOv8s (c√¢n b·∫±ng)</option>
                                <option value="yolov8m.pt">YOLOv8m (ch√≠nh x√°c)</option>
                                <option value="yolov8l.pt">YOLOv8l (r·∫•t ch√≠nh x√°c)</option>
                                <option value="yolov9s.pt">YOLOv9s</option>
                            </optgroup>
                            <optgroup label="TensorRT Engines (üöÄ TƒÉng t·ªëc)">
                                <option value="yolov8n_fp16.engine">YOLOv8n TensorRT FP16</option>
                                <option value="yolov8s_fp16.engine">YOLOv8s TensorRT FP16</option>
                                <option value="yolov8m_fp16.engine">YOLOv8m TensorRT FP16</option>
                                <option value="yolov8l_fp16.engine">YOLOv8l TensorRT FP16</option>
                                <option value="yolov9s_fp16.engine">YOLOv9s TensorRT FP16</option>
                                <option value="yolov8n_int8.engine">YOLOv8n TensorRT INT8</option>
                                <option value="yolov8s_int8.engine">YOLOv8s TensorRT INT8</option>
                                <option value="yolov8m_int8.engine">YOLOv8m TensorRT INT8</option>
                                <option value="yolov8l_int8.engine">YOLOv8l TensorRT INT8</option>
                                <option value="yolov9s_int8.engine">YOLOv9s TensorRT INT8</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <div class="control-group" id="quantizeControls" style="border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                        <label>üöÄ TensorRT Quantization:</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="precisionSelect" style="flex: 1;">
                                <option value="fp16">FP16 (khuy·∫øn ngh·ªã)</option>
                                <option value="int8">INT8 (nh·ªè nh·∫•t)</option>
                            </select>
                            <button id="quantizeBtn" onclick="quantizeCurrentModel()" style="background: linear-gradient(45deg, #FF6B35, #F7931E); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                ‚ö° T·∫°o Engine
                            </button>
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 5px;">
                            T·∫°o TensorRT engine t·ª´ PyTorch model ƒë·ªÉ tƒÉng t·ªëc inference
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button id="startBtn" onclick="startCounting()">üöÄ B·∫Øt ƒë·∫ßu</button>
                    <button id="stopBtn" class="stop-btn" onclick="stopCounting()" disabled>‚èπÔ∏è D·ª´ng</button>
                    <button id="resetBtn" class="reset-btn" onclick="resetSystem()">üîÑ Reset</button>
                    <button id="drawBtn" onclick="toggleDrawingMode()" disabled>üé® V·∫Ω l·∫°i</button>
                    <button id="testDrawBtn" onclick="testDrawingMode()" style="background: linear-gradient(45deg, #2196F3, #1976D2) !important;">üß™ V·∫Ω</button>
                </div>

                <div class="video-container">
                    <canvas id="videoCanvas" style="display: none; cursor: crosshair;"></canvas>
                    <img id="videoFeed" style="display: none;" />
                    <div class="no-video" id="noVideo">
                        üìπ Ch·ªçn c·∫•u h√¨nh v√† nh·∫•n "B·∫Øt ƒë·∫ßu" ƒë·ªÉ xem video
                    </div>
                    <div class="drawing-instructions" id="drawingInstructions" style="display: none;">
                        <div class="instruction-box">
                            <span id="instructionText">üìç Click 2 ƒëi·ªÉm ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒë·∫øm</span>
                            <button onclick="clearDrawing()" class="clear-btn">üóëÔ∏è X√≥a</button>
                            <button id="finishBtn" onclick="finishDrawing()" class="clear-btn" style="display: none; background: linear-gradient(45deg, #4CAF50, #45a049) !important;">‚úÖ Ho√†n th√†nh</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stats-header">
                    <h2>üìä Th·ªëng K√™</h2>
                    <div>
                        <span class="status-indicator" id="systemStatus"></span>
                        <span id="systemStatusText">ƒê√£ d·ª´ng</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value in-count" id="inCount">0</div>
                        <div class="stat-label">V√†o ‚ÜóÔ∏è</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value out-count" id="outCount">0</div>
                        <div class="stat-label">Ra ‚ÜôÔ∏è</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value net-count" id="netCount">0</div>
                        <div class="stat-label">R√≤ng üìä</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value zone-count" id="zoneCount">0</div>
                        <div class="stat-label">Trong v√πng üè¢</div>
                    </div>
                </div>

                <div class="log-section">
                    <div class="log-header">
                        <h3>üìù Log H·ªá Th·ªëng</h3>
                        <button onclick="clearLogs()" style="padding: 5px 10px; font-size: 0.8em;">üóëÔ∏è X√≥a</button>
                    </div>
                    <div class="log-container" id="logContainer">
                        <div class="log-entry info">
                            <span class="timestamp">[System]</span>
                            üöÄ H·ªá th·ªëng ƒë√£ s·∫µn s√†ng
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let isRunning = false;
        let currentMethod = 'line';
        let drawingMode = false;
        let canvas, ctx;
        let points = [];
        let isDrawingEnabled = false;
        let isTestMode = false;
        
        // Frame metadata ƒë·ªÉ t√≠nh to√°n t·ªça ƒë·ªô ch√≠nh x√°c
        let frameMetadata = {
            original_size: { width: 800, height: 600 },
            display_size: { width: 800, height: 600 },
            scale_factor: 1.0
        };

        // Canvas v√† drawing variables
        let canvasRect = null;

        // K·∫øt n·ªëi Socket.IO
        socket.on('connect', function() {
            console.log('Connected to server');
            updateConnectionStatus(true);
            addLog('info', '‚úÖ ƒê√£ k·∫øt n·ªëi v·ªõi server');
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            updateConnectionStatus(false);
            addLog('error', '‚ùå M·∫•t k·∫øt n·ªëi v·ªõi server');
        });

        // Nh·∫≠n frame video
        socket.on('video_frame', function(data) {
            const videoFeed = document.getElementById('videoFeed');
            const videoCanvas = document.getElementById('videoCanvas');
            const noVideo = document.getElementById('noVideo');
            
            // L∆∞u metadata frame ƒë·ªÉ t√≠nh to√°n t·ªça ƒë·ªô
            if (data.original_size && data.display_size) {
                frameMetadata = {
                    original_size: data.original_size,
                    display_size: data.display_size,
                    scale_factor: data.scale_factor || 1.0
                };
                console.log('üìä Frame metadata updated:', frameMetadata);
            } else if (data.frame_metadata) {
                frameMetadata = {
                    original_size: {
                        width: data.frame_metadata.original_width,
                        height: data.frame_metadata.original_height
                    },
                    display_size: {
                        width: data.frame_metadata.original_width,
                        height: data.frame_metadata.original_height
                    },
                    scale_factor: 1.0
                };
                console.log('üìä Frame metadata updated from frame_metadata:', frameMetadata);
            }
            
            // Hi·ªÉn th·ªã canvas thay v√¨ img khi ƒëang drawing
            if (isDrawingEnabled) {
                console.log('üé• Updating canvas with new frame, drawing enabled');
                
                const img = new Image();
                img.onload = function() {
                    // L∆∞u l·∫°i c√°c points hi·ªán t·∫°i tr∆∞·ªõc khi update canvas
                    const currentPoints = [...points];
                    
                    // Setup canvas v·ªõi display size 
                    const displayWidth = frameMetadata.display_size.width;
                    const displayHeight = frameMetadata.display_size.height;
                    
                    const needResize = (videoCanvas.width !== displayWidth || videoCanvas.height !== displayHeight);
                    
                    if (needResize) {
                        console.log('üìê Setting canvas to display size:', displayWidth, 'x', displayHeight);
                        console.log('üìä Original frame size:', frameMetadata.original_size.width, 'x', frameMetadata.original_size.height);
                        
                        // Update canvas size to match display size
                        videoCanvas.width = displayWidth;
                        videoCanvas.height = displayHeight;
                    }
                    
                    // Clear v√† v·∫Ω frame m·ªõi
                    ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
                    ctx.drawImage(this, 0, 0);
                    
                    // V·∫Ω l·∫°i c√°c ƒëi·ªÉm
                    drawPoints();
                    
                    // Update canvas rect cho mouse events (quan tr·ªçng!)
                    setTimeout(() => {
                        canvasRect = videoCanvas.getBoundingClientRect();
                        console.log('üìè Canvas rect updated:', {
                            left: canvasRect.left,
                            top: canvasRect.top,
                            width: canvasRect.width,
                            height: canvasRect.height,
                            canvasWidth: videoCanvas.width,
                            canvasHeight: videoCanvas.height,
                            frameMetadata: frameMetadata
                        });
                    }, 50);
                };
                img.src = 'data:image/jpeg;base64,' + (data.image || data.frame);
                
                videoCanvas.style.display = 'block';
                videoFeed.style.display = 'none';
            } else {
                videoFeed.src = 'data:image/jpeg;base64,' + (data.image || data.frame);
                videoFeed.style.display = 'block';
                videoCanvas.style.display = 'none';
            }
            
            noVideo.style.display = 'none';
            
            // C·∫≠p nh·∫≠t stats t·ª´ data (t∆∞∆°ng th√≠ch v·ªõi c·∫£ line v√† zone counting)
            if (data.stats) {
                console.log('üìä Video frame stats:', data.stats); // Debug log
                // Zone counting stats - ki·ªÉm tra c·∫£ format c≈© v√† m·ªõi
                const inCount = data.stats.entering || data.stats.in_count || 0;
                const outCount = data.stats.leaving || data.stats.out_count || 0;
                const zoneCount = data.stats.current_count || data.stats.zone_count || 0;
                
                document.getElementById('inCount').textContent = inCount;
                document.getElementById('outCount').textContent = outCount;
                document.getElementById('netCount').textContent = inCount - outCount;
                document.getElementById('zoneCount').textContent = zoneCount;
                
                // C·∫≠p nh·∫≠t FPS
                if (data.stats.fps) {
                    document.getElementById('fps').textContent = data.stats.fps.toFixed(1);
                }
            } else if (data.in_count !== undefined || data.out_count !== undefined) {
                console.log('üìä Direct stats:', {in: data.in_count, out: data.out_count, zone: data.zone_count}); // Debug log
                // Line counting stats ho·∫∑c direct stats
                document.getElementById('inCount').textContent = data.in_count || 0;
                document.getElementById('outCount').textContent = data.out_count || 0;
                document.getElementById('netCount').textContent = (data.in_count || 0) - (data.out_count || 0);
                document.getElementById('zoneCount').textContent = data.zone_count || 0;
            }
        });

        // Canvas drawing functions
        function initCanvas() {
            console.log('üé® Initializing canvas...');
            
            canvas = document.getElementById('videoCanvas');
            
            if (!canvas) {
                console.error('‚ùå Canvas element not found!');
                return false;
            }
            
            ctx = canvas.getContext('2d');
            
            if (!ctx) {
                console.error('‚ùå Canvas context not available!');
                return false;
            }
            
            console.log('‚úÖ Canvas initialized:', {
                element: !!canvas,
                context: !!ctx,
                width: canvas.width,
                height: canvas.height,
                clientWidth: canvas.clientWidth,
                clientHeight: canvas.clientHeight
            });
            
            // Remove existing event listeners to avoid duplicates
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('touchstart', handleTouchStart);
            canvas.removeEventListener('touchend', handleTouchEnd);
            
            // Add fresh event listeners
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            
            // Test event listener
            canvas.addEventListener('mousedown', function(e) {
                console.log('üñ±Ô∏è Mouse down detected on canvas');
            });
            
            console.log('‚úÖ Canvas event listeners added');
            return true;
        }

        function handleTouchStart(event) {
            event.preventDefault();
            if (!isDrawingEnabled) return;
            
            const touch = event.touches[0];
            const mouseEvent = new MouseEvent('click', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            
            handleCanvasClick(mouseEvent);
        }

        function handleTouchEnd(event) {
            event.preventDefault();
        }

        function handleCanvasClick(event) {
            console.log('üéØ Canvas click event triggered');
            
            if (!isDrawingEnabled) {
                console.log('‚ùå Drawing not enabled, ignoring click');
                return;
            }
            
            if (!canvas || !ctx) {
                console.error('‚ùå Canvas or context not available!');
                addLog('error', '‚ùå Canvas kh√¥ng s·∫µn s√†ng');
                return;
            }
            
            // L·∫•y canvas rect fresh m·ªói l·∫ßn click
            const rect = canvas.getBoundingClientRect();
            
            if (rect.width === 0 || rect.height === 0) {
                console.error('‚ùå Canvas has zero size!');
                addLog('error', '‚ùå Canvas c√≥ k√≠ch th∆∞·ªõc 0');
                return;
            }
            
            // T√≠nh t·ªça ƒë·ªô trong canvas display space
            const rawX = event.clientX - rect.left;
            const rawY = event.clientY - rect.top;
            
            // Scale t·ª´ browser display size v·ªÅ canvas internal size
            const canvasScaleX = canvas.width / rect.width;
            const canvasScaleY = canvas.height / rect.height;
            
            const canvasX = Math.round(rawX * canvasScaleX);
            const canvasY = Math.round(rawY * canvasScaleY);
            
            // Scale t·ª´ canvas size v·ªÅ original frame size  
            let originalX, originalY;
            if (frameMetadata && frameMetadata.original_size && frameMetadata.display_size) {
                const originalScaleX = frameMetadata.original_size.width / frameMetadata.display_size.width;
                const originalScaleY = frameMetadata.original_size.height / frameMetadata.display_size.height;
                originalX = Math.round(canvasX * originalScaleX);
                originalY = Math.round(canvasY * originalScaleY);
            } else {
                // Fallback cho zone counting  
                originalX = Math.round(canvasX);
                originalY = Math.round(canvasY);
            }
            
            console.log('üìç Coordinate transformation:', {
                event: {
                    clientX: event.clientX,
                    clientY: event.clientY
                },
                browserRect: {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    height: rect.height
                },
                canvas: {
                    width: canvas.width,
                    height: canvas.height
                },
                frameMetadata: frameMetadata,
                transformation: {
                    raw: { x: rawX, y: rawY },
                    canvasScale: { x: canvasScaleX, y: canvasScaleY },
                    canvasCoords: { x: canvasX, y: canvasY },
                    originalCoords: { x: originalX, y: originalY }
                }
            });
            
            // Validate coordinates trong canvas space (ƒë·ªÉ v·∫Ω)
            if (canvasX < 0 || canvasY < 0 || canvasX > canvas.width || canvasY > canvas.height) {
                console.warn('‚ö†Ô∏è Canvas coordinates outside bounds:', {canvasX, canvasY, maxX: canvas.width, maxY: canvas.height});
                addLog('warning', `‚ö†Ô∏è Click ngo√†i canvas: (${canvasX}, ${canvasY})`);
                return;
            }
            
            // Validate coordinates trong original frame space
            if (frameMetadata && frameMetadata.original_size && (originalX < 0 || originalY < 0 || originalX > frameMetadata.original_size.width || originalY > frameMetadata.original_size.height)) {
                console.warn('‚ö†Ô∏è Original coordinates outside bounds:', {originalX, originalY, maxX: frameMetadata.original_size.width, maxY: frameMetadata.original_size.height});
            }
            
            // L∆∞u c·∫£ 2 b·ªô t·ªça ƒë·ªô: canvas ƒë·ªÉ v·∫Ω, original ƒë·ªÉ g·ª≠i server
            const newPoint = {
                // Canvas coordinates ƒë·ªÉ v·∫Ω tr√™n UI
                x: canvasX,
                y: canvasY,
                // Original coordinates ƒë·ªÉ g·ª≠i cho backend processing
                originalX: originalX,
                originalY: originalY
            };
            
            points.push(newPoint);
            
            const maxPoints = currentMethod === 'line' ? 2 : 8;
            
            console.log(`‚úÖ Added point ${points.length}/${maxPoints}:`, newPoint);
            addLog('info', `üìç ƒêi·ªÉm ${points.length}: Canvas(${canvasX}, ${canvasY}) ‚Üí Original(${originalX}, ${originalY})`);
            
            // V·∫Ω ngay l·∫≠p t·ª©c
            drawPoints();
            updateInstructionText();
            
            // Auto finish cho line khi c√≥ ƒë·ªß 2 ƒëi·ªÉm
            if (currentMethod === 'line' && points.length >= 2) {
                console.log('üéâ Line drawing completed, finishing...');
                setTimeout(() => {
                    finishDrawing();
                }, 100);
            }
            // Auto finish cho zone khi c√≥ ƒë·ªß 8 ƒëi·ªÉm, ho·∫∑c cho ph√©p finish manual khi c√≥ √≠t nh·∫•t 3 ƒëi·ªÉm
            else if (currentMethod === 'zone' && points.length >= 8) {
                console.log('üéâ Zone drawing completed, finishing...');
                setTimeout(() => {
                    finishDrawing();
                }, 100);
            }
            else if (currentMethod === 'zone' && points.length >= 3) {
                // Hi·ªÉn th·ªã n√∫t finish cho zone khi c√≥ √≠t nh·∫•t 3 ƒëi·ªÉm
                showFinishButton();
            }
        }

        function drawPoints() {
            if (!ctx || points.length === 0) {
                console.log('üé® No context or points to draw');
                return;
            }
            
            console.log('üé® Drawing points:', points);
            
            // Save current context state
            ctx.save();
            
            // Set drawing styles
            ctx.strokeStyle = '#00ff00';
            ctx.fillStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
            ctx.shadowBlur = 5;
            
            // V·∫Ω c√°c ƒëi·ªÉm
            points.forEach((point, index) => {
                console.log(`Drawing point ${index + 1}:`, point);
                
                // V·∫Ω ƒëi·ªÉm tr√≤n
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // V·∫Ω border cho ƒëi·ªÉm
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Hi·ªÉn th·ªã s·ªë th·ª© t·ª±
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 16px Arial';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeText((index + 1).toString(), point.x + 12, point.y - 8);
                ctx.fillText((index + 1).toString(), point.x + 12, point.y - 8);
                
                // Reset styles for next iteration
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
            });
            
            // V·∫Ω ƒë∆∞·ªùng n·ªëi
            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                if (currentMethod === 'line') {
                    // V·∫Ω ƒë∆∞·ªùng th·∫≥ng
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                } else {
                    // V·∫Ω polygon
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    if (points.length >= 3) {
                        ctx.closePath();
                    }
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = 'rgba(0, 255, 0, 0.5)';
                }
                
                ctx.stroke();
            }
            
            // Restore context state
            ctx.restore();
            
            console.log('üé® Points drawn successfully');
        }

        function clearDrawing() {
            console.log('üóëÔ∏è Clearing drawing');
            
            points = [];
            hideFinishButton(); // ·∫®n n√∫t finish khi x√≥a
            if (ctx && canvas.width > 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                console.log('Canvas cleared');
                
                // N·∫øu ƒëang trong video mode, v·∫Ω l·∫°i frame hi·ªán t·∫°i
                if (isDrawingEnabled && !isTestMode) {
                    const videoFeed = document.getElementById('videoFeed');
                    if (videoFeed.src) {
                        const img = new Image();
                        img.onload = function() {
                            ctx.drawImage(this, 0, 0);
                        };
                        img.src = videoFeed.src;
                    }
                }
            }
            updateInstructionText();
            
            // G·ª≠i clear command t·ªõi server
            socket.emit('clear_drawing');
            
            addLog('info', 'üóëÔ∏è ƒê√£ x√≥a drawing');
        }

        function debugCoordinates(event) {
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const rawX = event.clientX - rect.left;
            const rawY = event.clientY - rect.top;
            const scaledX = Math.round(rawX * scaleX);
            const scaledY = Math.round(rawY * scaleY);
            
            console.log('üß™ Debug coordinates:', {
                mouse: { x: event.clientX, y: event.clientY },
                rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },
                canvas: { width: canvas.width, height: canvas.height },
                scale: { x: scaleX, y: scaleY },
                relative: { x: rawX, y: rawY },
                final: { x: scaledX, y: scaledY }
            });
            
            return { x: scaledX, y: scaledY };
        }

        function finishDrawing() {
            console.log('üéâ Finishing drawing with points:', points);
            
            isDrawingEnabled = false;
            hideFinishButton(); // ·∫®n n√∫t finish
            document.getElementById('drawingInstructions').style.display = 'none';
            
            // Chu·∫©n b·ªã points ƒë·ªÉ g·ª≠i server - s·ª≠ d·ª•ng original coordinates
            const serverPoints = points.map(point => ({
                x: point.originalX || point.x,  // Fallback n·∫øu kh√¥ng c√≥ originalX
                y: point.originalY || point.y   // Fallback n·∫øu kh√¥ng c√≥ originalY
            }));
            
            console.log('üì§ Sending points to server:', {
                method: currentMethod,
                points: serverPoints,
                frameMetadata: frameMetadata
            });
            
            socket.emit('set_drawing_points', {
                method: currentMethod,
                points: serverPoints
            });
            
            addLog('info', `‚úÖ ƒê√£ thi·∫øt l·∫≠p ${currentMethod === 'line' ? 'ƒë∆∞·ªùng ƒë·∫øm' : 'v√πng ƒë·∫øm'} v·ªõi ${serverPoints.length} ƒëi·ªÉm`);
            addLog('info', `üìä Frame: ${frameMetadata.original_size.width}x${frameMetadata.original_size.height} ‚Üí Display: ${frameMetadata.display_size.width}x${frameMetadata.display_size.height}`);
        }

        function updateInstructionText() {
            const instructionText = document.getElementById('instructionText');
            const maxPoints = currentMethod === 'line' ? 2 : 8;
            const remaining = maxPoints - points.length;
            
            if (remaining > 0) {
                if (currentMethod === 'line') {
                    instructionText.textContent = `üìç Click ${remaining} ƒëi·ªÉm ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒë·∫øm`;
                } else {
                    if (points.length < 3) {
                        instructionText.textContent = `üìç Click ${3 - points.length} ƒëi·ªÉm ƒë·ªÉ v·∫Ω v√πng ƒë·∫øm (t·ªëi thi·ªÉu)`;
                    } else {
                        instructionText.textContent = `üìç Click th√™m ${remaining} ƒëi·ªÉm ho·∫∑c nh·∫•n "Ho√†n th√†nh" (${points.length} ƒëi·ªÉm)`;
                    }
                }
            } else {
                instructionText.textContent = '‚úÖ Ho√†n th√†nh!';
            }
        }

        function showFinishButton() {
            const finishBtn = document.getElementById('finishBtn');
            if (finishBtn) {
                finishBtn.style.display = 'inline-block';
                console.log('‚úÖ Finish button shown');
            }
        }

        function hideFinishButton() {
            const finishBtn = document.getElementById('finishBtn');
            if (finishBtn) {
                finishBtn.style.display = 'none';
            }
        }

        // Nh·∫≠n c·∫≠p nh·∫≠t th·ªëng k√™
        socket.on('stats_update', function(data) {
            console.log('üìä Received stats_update:', data); // Debug log
            document.getElementById('inCount').textContent = data.in_count || 0;
            document.getElementById('outCount').textContent = data.out_count || 0;
            document.getElementById('netCount').textContent = (data.in_count || 0) - (data.out_count || 0);
            document.getElementById('zoneCount').textContent = data.zone_count || 0;
        });

        // Nh·∫≠n log messages
        socket.on('log_message', function(data) {
            addLog(data.level, data.message);
        });

        // Nh·∫≠n tr·∫°ng th√°i h·ªá th·ªëng
        socket.on('system_status', function(data) {
            updateSystemStatus(data.status, data.message);
        });

        // Debug socket events
        socket.on('connect_error', function(error) {
            console.error('Socket connection error:', error);
            addLog('error', '‚ùå L·ªói k·∫øt n·ªëi Socket.IO');
        });

        socket.on('error', function(error) {
            console.error('Socket error:', error);
            addLog('error', '‚ùå L·ªói Socket.IO: ' + error);
        });

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const indicator = status.querySelector('.status-indicator');
            
            if (connected) {
                status.className = 'connection-status connected';
                status.innerHTML = '<span class="status-indicator status-running"></span>ƒê√£ k·∫øt n·ªëi';
            } else {
                status.className = 'connection-status disconnected';
                status.innerHTML = '<span class="status-indicator status-stopped"></span>M·∫•t k·∫øt n·ªëi';
            }
        }

        function updateSystemStatus(status, message) {
            const indicator = document.getElementById('systemStatus');
            const text = document.getElementById('systemStatusText');
            
            indicator.className = 'status-indicator status-' + status;
            text.textContent = message;
            
            isRunning = (status === 'running');
            updateButtons();
            
            // Ch·ªâ enable drawing mode cho zone counting t·ª± ƒë·ªông
            // Line counting c·∫ßn ng∆∞·ªùi d√πng b·∫•m n√∫t Draw manually
            if (isRunning && currentMethod === 'zone') {
                enableDrawingMode();
            } else if (!isRunning) {
                disableDrawingMode();
            }
        }

        function updateButtons() {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const drawBtn = document.getElementById('drawBtn');
            
            startBtn.disabled = isRunning;
            stopBtn.disabled = !isRunning;
            drawBtn.disabled = !isRunning;
        }

        function toggleDrawingMode() {
            if (isDrawingEnabled) {
                disableDrawingMode();
                addLog('info', 'üé® ƒê√£ t·∫Øt ch·∫ø ƒë·ªô v·∫Ω');
            } else {
                enableDrawingMode();
            }
        }

        function enableDrawingMode() {
            currentMethod = document.getElementById('methodSelect').value;
            isDrawingEnabled = true;
            points = [];
            hideFinishButton(); // ·∫®n n√∫t finish khi b·∫Øt ƒë·∫ßu v·∫Ω m·ªõi
            
            console.log('Enabling drawing mode for method:', currentMethod);
            
            document.getElementById('drawingInstructions').style.display = 'block';
            updateInstructionText();
            
            // ƒê·∫£m b·∫£o canvas ƒë∆∞·ª£c hi·ªÉn th·ªã v√† c√≥ th·ªÉ t∆∞∆°ng t√°c
            const videoCanvas = document.getElementById('videoCanvas');
            const videoFeed = document.getElementById('videoFeed');
            
            if (videoFeed.style.display !== 'none' && videoFeed.src) {
                // N·∫øu c√≥ video ƒëang hi·ªÉn th·ªã, chuy·ªÉn sang canvas mode
                videoCanvas.style.display = 'block';
                videoFeed.style.display = 'none';
                
                // Copy current frame to canvas
                const img = new Image();
                img.onload = function() {
                    videoCanvas.width = this.width;
                    videoCanvas.height = this.height;
                    ctx.drawImage(this, 0, 0);
                    console.log('Canvas updated with current frame');
                };
                img.src = videoFeed.src;
            }
            
            addLog('info', `üé® Ch·∫ø ƒë·ªô v·∫Ω ${currentMethod === 'line' ? 'ƒë∆∞·ªùng' : 'v√πng'} ƒë√£ b·∫≠t`);
        }

        function disableDrawingMode() {
            isDrawingEnabled = false;
            document.getElementById('drawingInstructions').style.display = 'none';
            
            // Chuy·ªÉn v·ªÅ hi·ªÉn th·ªã video feed b√¨nh th∆∞·ªùng
            document.getElementById('videoCanvas').style.display = 'none';
            document.getElementById('videoFeed').style.display = 'none';
            document.getElementById('noVideo').style.display = 'block';
        }

        function addLog(level, message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${level}`;
            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span>${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng log entries
            const entries = logContainer.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        function startCounting() {
            const method = document.getElementById('methodSelect').value;
            const video = document.getElementById('videoInput').value;
            const model = document.getElementById('modelSelect').value;
            
            currentMethod = method;
            
            socket.emit('start_counting', {
                method: method,
                video: video,
                model: model
            });
            
            addLog('info', `üöÄ B·∫Øt ƒë·∫ßu ${method} counting v·ªõi ${model}`);
        }

        function stopCounting() {
            socket.emit('stop_counting');
            addLog('warning', '‚èπÔ∏è ƒê√£ d·ª´ng h·ªá th·ªëng');
            
            disableDrawingMode();
        }

        function resetSystem() {
            socket.emit('reset_system');
            
            // Reset stats
            document.getElementById('inCount').textContent = '0';
            document.getElementById('outCount').textContent = '0';
            document.getElementById('netCount').textContent = '0';
            document.getElementById('zoneCount').textContent = '0';
            
            // Reset drawing
            clearDrawing();
            
            addLog('info', 'üîÑ ƒê√£ reset h·ªá th·ªëng');
        }

        function clearLogs() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '<div class="log-entry info"><span class="timestamp">[System]</span>üìù Log ƒë√£ ƒë∆∞·ª£c x√≥a</div>';
        }

        function testDrawingMode() {
            console.log('üß™ Testing drawing mode - START');
            addLog('info', 'üß™ B·∫Øt ƒë·∫ßu test drawing mode');
            
            // Set test mode flag
            isTestMode = true;
            
            // Re-initialize canvas to ensure it's ready
            if (!initCanvas()) {
                addLog('error', '‚ùå Kh√¥ng th·ªÉ kh·ªüi t·∫°o canvas');
                return;
            }
            
            // Reset state
            currentMethod = document.getElementById('methodSelect').value;
            isDrawingEnabled = true;
            points = [];
            
            // L·∫•y canvas v√† setup
            const videoCanvas = document.getElementById('videoCanvas');
            const videoFeed = document.getElementById('videoFeed');
            const noVideo = document.getElementById('noVideo');
            
            console.log('üîç Elements check:', {
                videoCanvas: !!videoCanvas,
                videoFeed: !!videoFeed,
                noVideo: !!noVideo,
                canvas: !!canvas,
                ctx: !!ctx
            });
            
            // ·∫®n t·∫•t c·∫£ elements kh√°c
            videoFeed.style.display = 'none';
            noVideo.style.display = 'none';
            
            // Hi·ªÉn th·ªã v√† setup canvas
            videoCanvas.style.display = 'block';
            videoCanvas.style.position = 'relative';
            videoCanvas.style.zIndex = '10';
            videoCanvas.style.border = '2px solid #00ff00';
            videoCanvas.style.cursor = 'crosshair';
            
            // Set canvas size explicitly
            videoCanvas.width = 800;
            videoCanvas.height = 600;
            
            // Force layout recalculation
            videoCanvas.offsetHeight;
            
            console.log('üìê Canvas dimensions after setup:', {
                width: videoCanvas.width,
                height: videoCanvas.height,
                clientWidth: videoCanvas.clientWidth,
                clientHeight: videoCanvas.clientHeight,
                offsetWidth: videoCanvas.offsetWidth,
                offsetHeight: videoCanvas.offsetHeight,
                style: videoCanvas.style.cssText
            });
            
            // V·∫Ω background test
            if (ctx) {
                // Clear canvas first
                ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
                
                // Draw dark background
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, videoCanvas.width, videoCanvas.height);
                
                // Draw grid for easier visualization
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 1;
                for (let x = 0; x < videoCanvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, videoCanvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < videoCanvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(videoCanvas.width, y);
                    ctx.stroke();
                }
                
                // Draw instruction text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üß™ TEST CANVAS - CLICK ƒê·ªÇ V·∫º', videoCanvas.width/2, videoCanvas.height/2 - 20);
                
                ctx.font = '18px Arial';
                ctx.fillStyle = '#00ff00';
                ctx.fillText(`Mode: ${currentMethod.toUpperCase()}`, videoCanvas.width/2, videoCanvas.height/2 + 20);
                
                // Draw border
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, 0, videoCanvas.width, videoCanvas.height);
                
                console.log('‚úÖ Canvas background, grid v√† instructions ƒë√£ v·∫Ω');
            } else {
                console.error('‚ùå Canvas context kh√¥ng kh·∫£ d·ª•ng!');
                addLog('error', '‚ùå Canvas context kh√¥ng kh·∫£ d·ª•ng');
                return;
            }
            
            // Hi·ªÉn th·ªã drawing instructions
            videoCanvas.style.display = 'block';
            videoFeed.style.display = 'none';
            noVideo.style.display = 'none';
            
            // Hi·ªÉn th·ªã instructions
            document.getElementById('drawingInstructions').style.display = 'block';
            updateInstructionText();
            
            addLog('info', `üé® Test drawing mode ƒë√£ b·∫≠t cho ${currentMethod}`);
            addLog('info', 'üìç Click tr√™n video ƒë·ªÉ v·∫Ω');
            
            // Test click simulation
            setTimeout(() => {
                addLog('info', 'üß™ Click tr√™n canvas m√†u ƒëen ƒë·ªÉ test');
            }, 1000);
        }

        // Kh·ªüi t·∫°o
        window.addEventListener('load', function() {
            console.log('Page loaded, initializing...');
            
            // Test canvas support
            const testCanvas = document.createElement('canvas');
            const testCtx = testCanvas.getContext('2d');
            console.log('Canvas support:', !!testCtx);
            
            initCanvas();
            updateButtons();
            updateConnectionStatus(false);
            loadAvailableModels();
            
            // Test drawing initialization
            setTimeout(() => {
                console.log('Canvas element:', document.getElementById('videoCanvas'));
                console.log('Canvas context:', ctx);
                addLog('info', 'üöÄ Trang web ƒë√£ t·∫£i xong');
            }, 1000);
        });

        // Load available models from server
        async function loadAvailableModels() {
            try {
                const response = await fetch('/api/models');
                const data = await response.json();
                updateModelSelect(data.models);
                updateTensorRTStatus(data.models.tensorrt.length > 0);
            } catch (error) {
                console.error('Failed to load models:', error);
                addLog('warning', '‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i danh s√°ch models');
            }
        }

        // Update model select with available models
        function updateModelSelect(models) {
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = '';
            
            // PyTorch models group
            if (models.pytorch.length > 0) {
                const pytorchGroup = document.createElement('optgroup');
                pytorchGroup.label = 'PyTorch Models';
                models.pytorch.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = getModelDisplayName(model);
                    pytorchGroup.appendChild(option);
                });
                modelSelect.appendChild(pytorchGroup);
            }
            
            // TensorRT models group
            if (models.tensorrt.length > 0) {
                const tensorrtGroup = document.createElement('optgroup');
                tensorrtGroup.label = 'TensorRT Engines (üöÄ TƒÉng t·ªëc)';
                models.tensorrt.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = getModelDisplayName(model);
                    tensorrtGroup.appendChild(option);
                });
                modelSelect.appendChild(tensorrtGroup);
            }
            
            // Set default selection
            if (models.pytorch.includes('yolov8s.pt')) {
                modelSelect.value = 'yolov8s.pt';
            } else if (models.pytorch.length > 0) {
                modelSelect.value = models.pytorch[0];
            }
        }

        // Get display name for model
        function getModelDisplayName(model) {
            const displayNames = {
                'yolov8n.pt': 'YOLOv8n (nhanh)',
                'yolov8s.pt': 'YOLOv8s (c√¢n b·∫±ng)',
                'yolov8m.pt': 'YOLOv8m (ch√≠nh x√°c)',
                'yolov8l.pt': 'YOLOv8l (r·∫•t ch√≠nh x√°c)',
                'yolov9s.pt': 'YOLOv9s',
                'yolov8n_fp16.engine': 'YOLOv8n TensorRT FP16',
                'yolov8s_fp16.engine': 'YOLOv8s TensorRT FP16',
                'yolov8m_fp16.engine': 'YOLOv8m TensorRT FP16',
                'yolov8l_fp16.engine': 'YOLOv8l TensorRT FP16',
                'yolov9s_fp16.engine': 'YOLOv9s TensorRT FP16',
                'yolov8n_int8.engine': 'YOLOv8n TensorRT INT8',
                'yolov8s_int8.engine': 'YOLOv8s TensorRT INT8',
                'yolov8m_int8.engine': 'YOLOv8m TensorRT INT8',
                'yolov8l_int8.engine': 'YOLOv8l TensorRT INT8',
                'yolov9s_int8.engine': 'YOLOv9s TensorRT INT8'
            };
            return displayNames[model] || model;
        }

        // Update TensorRT status indicator
        function updateTensorRTStatus(available) {
            // Add status indicator near model select
            const modelGroup = document.querySelector('.control-group:has(#modelSelect)');
            if (modelGroup) {
                let statusIndicator = modelGroup.querySelector('.tensorrt-status');
                if (!statusIndicator) {
                    statusIndicator = document.createElement('div');
                    statusIndicator.className = 'tensorrt-status';
                    statusIndicator.style.cssText = 'font-size: 12px; margin-top: 5px; padding: 3px 6px; border-radius: 3px;';
                    modelGroup.appendChild(statusIndicator);
                }
                
                if (available) {
                    statusIndicator.innerHTML = 'üöÄ TensorRT Available';
                    statusIndicator.style.backgroundColor = '#4CAF50';
                    statusIndicator.style.color = 'white';
                } else {
                    statusIndicator.innerHTML = '‚ö†Ô∏è TensorRT Not Available';
                    statusIndicator.style.backgroundColor = '#FF9800';
                    statusIndicator.style.color = 'white';
                }
            }
        }

        // Quantize current selected model
        async function quantizeCurrentModel() {
            const modelSelect = document.getElementById('modelSelect');
            const precisionSelect = document.getElementById('precisionSelect');
            const quantizeBtn = document.getElementById('quantizeBtn');
            
            const selectedModel = modelSelect.value;
            const selectedPrecision = precisionSelect.value;
            
            // Only quantize PyTorch models
            if (!selectedModel.endsWith('.pt')) {
                addLog('warning', '‚ö†Ô∏è Ch·ªâ c√≥ th·ªÉ quantize PyTorch models (.pt)');
                return;
            }
            
            // Disable button and show progress
            quantizeBtn.disabled = true;
            quantizeBtn.innerHTML = '‚è≥ ƒêang t·∫°o...';
            
            try {
                const response = await fetch(`/api/quantize/${selectedModel}/${selectedPrecision}`);
                const data = await response.json();
                
                if (data.status === 'started') {
                    addLog('info', data.message);
                    addLog('info', '‚è±Ô∏è Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t...');
                } else {
                    addLog('error', '‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu quantization');
                }
            } catch (error) {
                addLog('error', `‚ùå L·ªói quantization: ${error.message}`);
            } finally {
                // Re-enable button after 5 seconds
                setTimeout(() => {
                    quantizeBtn.disabled = false;
                    quantizeBtn.innerHTML = '‚ö° T·∫°o Engine';
                }, 5000);
            }
        }

        // Listen for quantization completion
        socket.on('quantization_complete', function(data) {
            if (data.success) {
                addLog('success', data.message);
                // Reload models to show new engine
                loadAvailableModels();
            } else {
                addLog('error', `‚ùå Quantization failed: ${data.error}`);
            }
            
            // Re-enable quantize button
            const quantizeBtn = document.getElementById('quantizeBtn');
            quantizeBtn.disabled = false;
            quantizeBtn.innerHTML = '‚ö° T·∫°o Engine';
        });
    </script>
</body>
</html>
